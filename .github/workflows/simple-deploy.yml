name: Simple Deploy Pipeline

on:
  push:
    branches: [ master, main ]
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY: water-quality-ml

jobs:
  build-and-deploy:
    name: Build & Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get commit hash
        id: commit
        run: echo "hash=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Download model artifacts
        run: |
          # Create directories
          mkdir -p data/processed app/model_registry
          
          # If you have model files in DVC/S3, add download logic here
          # For now, assumes model artifacts are in the repo or will be added manually
          echo "Model artifacts prepared"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          IMAGE_TAG: ${{ steps.commit.outputs.hash }}
        run: |
          # Build image
          docker build -f docker/Dockerfile.prod \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            --build-arg GIT_COMMIT=${{ github.sha }} \
            --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") .
          
          # Push to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Deploy to EC2 via SSM
        run: |
          set -euo pipefail
          
          # Get instance ID
          INSTANCE_ID="${{ secrets.PROD_EC2_INSTANCE_ID }}"
          if [ -z "$INSTANCE_ID" ]; then
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=mlops-production" "Name=instance-state-name,Values=running" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text)
          fi
          
          echo "Deploying to instance: $INSTANCE_ID"
          
          IMAGE_URI="${{ steps.build.outputs.image_uri }}"
          ECR_REGISTRY="${{ secrets.ECR_REGISTRY }}"
          
          # Deployment script
          cat > /tmp/deploy.sh << 'SCRIPT'
          #!/bin/bash
          set -e
          
          # Variables
          IMAGE_URI="${IMAGE_URI}"
          ECR_REGISTRY="${ECR_REGISTRY}"
          AWS_REGION="${AWS_REGION}"
          APP_DIR="/opt/mlops-production"
          APP_PORT="8000"
          
          echo "===== Starting Deployment ====="
          echo "Image: $IMAGE_URI"
          
          # Ensure Docker is running
          sudo systemctl start docker || true
          
          # Login to ECR
          aws ecr get-login-password --region $AWS_REGION | \
            sudo docker login --username AWS --password-stdin $ECR_REGISTRY
          
          # Pull new image
          sudo docker pull $IMAGE_URI
          
          # Stop old container
          sudo docker stop water-quality-app 2>/dev/null || true
          sudo docker rm water-quality-app 2>/dev/null || true
          
          # Run new container
          sudo docker run -d \
            --name water-quality-app \
            --restart unless-stopped \
            -p $APP_PORT:8000 \
            -e AWS_REGION=$AWS_REGION \
            -e ENVIRONMENT=production \
            --log-driver=json-file \
            --log-opt max-size=100m \
            --log-opt max-file=3 \
            $IMAGE_URI
          
          # Health check
          echo "Waiting for application to start..."
          sleep 10
          
          for i in {1..30}; do
            if curl -sf http://localhost:$APP_PORT/ >/dev/null 2>&1; then
              echo "✅ Application is healthy!"
              exit 0
            fi
            echo "Attempt $i/30..."
            sleep 2
          done
          
          echo "❌ Health check failed"
          sudo docker logs water-quality-app --tail 50
          exit 1
          SCRIPT
          
          # Send deployment command via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Simple deploy - $IMAGE_URI" \
            --parameters commands="$(cat /tmp/deploy.sh)" \
            --environment-variables \
              "IMAGE_URI=$IMAGE_URI" \
              "ECR_REGISTRY=$ECR_REGISTRY" \
              "AWS_REGION=$AWS_REGION" \
            --query "Command.CommandId" \
            --output text)
          
          echo "SSM Command ID: $COMMAND_ID"
          
          # Wait for completion
          echo "Waiting for deployment to complete..."
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            echo "[$i/60] Status: $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment successful!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              exit 0
            elif [ "$STATUS" = "Failed" ]; then
              echo "❌ Deployment failed!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            fi
            
            sleep 5
          done
          
          echo "⏱️ Deployment timed out"
          exit 1

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.build.outputs.image_uri }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: production" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
